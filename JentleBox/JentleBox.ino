/* JentleBox
 * @Knowblesse 2022
 * Fear conditioning box with internal tone generator
 */
#include "AD9833.h"
#include "VariableResistor.h"
#include <SPI.h>
#include <U8g2lib.h>

// +---------------------------------------------------------------------------------+
// |                             Digial Pin Configuration                            |
// +---------------------------------------------------------------------------------+
#define PIN_IO_TERMINAL1 2
#define PIN_IO_TERMINAL2 13
#define PIN_IO_TERMINAL3 4
#define PIN_IO_TERMINAL4 5
#define PIN_BTN_CLK 6
#define PIN_CS_TRIGGER 7 // digital input signal for external cs on trigger
#define PIN_CS_ENABLE 8  // Not used
#define PIN_BTN_R1 9
#define PIN_BTN_R2 10
#define PIN_RESISTOR_CS 16
#define PIN_DDS_CS 3
#define PIN_LCD_A0 18
#define PIN_LCD_RESET 19
#define PIN_LCD_CS 20
#define PIN_LCD_LED 21 // Not used

// Open Screen
PROGMEM static unsigned char welcome[] = {
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
   0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x83, 0xc3, 0x01, 0x70,
   0x0e, 0x00, 0x80, 0x8f, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0x43, 0x26, 0x03, 0xc8, 0x19, 0x00, 0xc0, 0x18, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0x23, 0x1c, 0x06, 0x84, 0x31, 0x00, 0x40, 0x18,
   0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x23, 0x1c, 0x06, 0x84,
   0x31, 0x00, 0x20, 0x1c, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0x23, 0x1c, 0x06, 0x84, 0x31, 0x00, 0x30, 0x0c, 0x06, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xc0, 0x23, 0x1c, 0xfe, 0x84, 0xf1, 0x0f, 0x18, 0x06,
   0x86, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x23, 0x1c, 0xfe, 0x87,
   0xf1, 0x1f, 0x0c, 0x07, 0xc6, 0x16, 0x00, 0x00, 0x7e, 0x00, 0x00, 0xc0,
   0x23, 0x1c, 0x83, 0x87, 0x31, 0x38, 0x84, 0x03, 0xe6, 0x24, 0x00, 0x00,
   0xc3, 0x01, 0xfc, 0xc0, 0x23, 0x00, 0x01, 0x8f, 0x31, 0x70, 0x86, 0x01,
   0x26, 0x49, 0x03, 0x80, 0x01, 0x01, 0x87, 0xc1, 0x23, 0x00, 0x39, 0x9e,
   0x31, 0x60, 0xc2, 0x01, 0x66, 0x92, 0x02, 0xc0, 0x00, 0x82, 0x01, 0xc7,
   0x23, 0x00, 0x39, 0xbb, 0xb1, 0x63, 0xe2, 0x00, 0xa6, 0xc4, 0x02, 0x40,
   0x00, 0x46, 0x00, 0xc4, 0x23, 0x1c, 0x81, 0xb3, 0xb1, 0x63, 0x7c, 0x00,
   0x26, 0x41, 0x02, 0x60, 0x00, 0x66, 0x00, 0xcc, 0x23, 0x1c, 0xe1, 0xb9,
   0xb1, 0x63, 0x00, 0x00, 0x46, 0x40, 0x02, 0x20, 0x00, 0x26, 0x00, 0xc8,
   0x23, 0x1c, 0xf1, 0xb8, 0xb1, 0x63, 0x1e, 0x00, 0xc6, 0x20, 0x02, 0x20,
   0x00, 0x26, 0x00, 0xc8, 0x23, 0x1c, 0x01, 0x98, 0x31, 0x60, 0x31, 0x00,
   0x86, 0x00, 0x02, 0x20, 0x1c, 0x3e, 0x00, 0xc8, 0x23, 0x1c, 0x03, 0x8c,
   0x30, 0x70, 0x31, 0x00, 0x03, 0x03, 0x0f, 0x20, 0x38, 0x22, 0x38, 0xc8,
   0x43, 0x26, 0x8f, 0xcf, 0x39, 0x38, 0x31, 0x00, 0x03, 0x86, 0x09, 0x60,
   0x70, 0x00, 0x1e, 0xcc, 0x83, 0xc3, 0xf9, 0x77, 0xee, 0x1f, 0x1e, 0x00,
   0x03, 0xcc, 0x18, 0x40, 0x00, 0x00, 0x0e, 0xce, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x80, 0x01, 0x78, 0x30, 0xc0, 0x07, 0x00, 0x06, 0xce,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x01, 0x1c, 0x20, 0x00,
   0x0c, 0x00, 0x00, 0xc7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0,
   0x01, 0x0c, 0x60, 0x00, 0x08, 0x00, 0xe0, 0xc3, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0xe0, 0x00, 0x0c, 0xc0, 0x00, 0x6c, 0x30, 0xfc, 0xc1,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x0c, 0xc0, 0xf8,
   0x67, 0x30, 0x18, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
   0x00, 0x1c, 0x80, 0x29, 0x00, 0x00, 0x1c, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x18, 0x00, 0x38, 0x80, 0x39, 0x00, 0x00, 0x0c, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x38, 0x00, 0x23,
   0x00, 0x00, 0x0e, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
   0x00, 0x70, 0x00, 0x27, 0x00, 0x00, 0x06, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x1c, 0x00, 0x60, 0x00, 0x6e, 0x00, 0x00, 0x06, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0xe0, 0x00, 0xdc,
   0x00, 0x02, 0x0e, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0,
   0x00, 0xc0, 0x00, 0xb8, 0x01, 0x41, 0x3c, 0xc0, 0x07, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x0c, 0xc0, 0x03, 0xc0, 0x00, 0xf0, 0xc3, 0x78, 0x6c, 0xc0,
   0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0x01, 0x80, 0x01, 0xe0,
   0x3f, 0x7e, 0xc4, 0xc3, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x3f,
   0x00, 0x80, 0x03, 0x00, 0xff, 0x1f, 0x83, 0xdf, 0xf3, 0x07, 0x00, 0x00,
   0x00, 0xe0, 0x0f, 0x00, 0x00, 0x00, 0x03, 0x00, 0x10, 0x03, 0x81, 0xff,
   0x83, 0xdf, 0x01, 0x00, 0x00, 0xfe, 0x03, 0x00, 0x00, 0x00, 0x07, 0x00,
   0x18, 0xe3, 0xc1, 0xf3, 0x03, 0xfe, 0x07, 0x00, 0xf0, 0x7f, 0x00, 0x00,
   0x00, 0x00, 0x0e, 0x00, 0x88, 0xbf, 0xe0, 0xc3, 0x03, 0xf0, 0xff, 0xff,
   0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x88, 0x81, 0xf0, 0xc0,
   0x03, 0x00, 0xfc, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
   0x88, 0xc1, 0x70, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x38, 0x00, 0x98, 0xc1, 0x38, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0xf8, 0xc1, 0x1f, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x01,
   0xb8, 0x61, 0x3c, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0xc0, 0x07, 0x8c, 0x21, 0x60, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x07, 0x86, 0x21, 0xe0, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
   0x86, 0x21, 0xf0, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x0f, 0x86, 0x21, 0x70, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x86, 0x21, 0x78, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
   0xc6, 0x20, 0x78, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x0e, 0xc6, 0x20, 0x7c, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xce, 0x20, 0x3c, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c,
   0xce, 0x20, 0x1e, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x08, 0xcc, 0x30, 0x0f, 0xc0, 0x03, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xc8, 0x10, 0x03, 0xc0,
   0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
   0xd8, 0x90, 0x01, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x18, 0xd8, 0xd0, 0x01, 0xc0, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff };

// Setting Value
bool isSetMode = false;
bool soundOn = false;
bool manualSoundOn = false;
bool prevSoundOn = false;

int freq = 2000;
int volume = 140;
unsigned long rampDuration = 100;

// Min Max Value
int Max_volume = 150;
int Min_volume = 1;
int Chn_volume = 1;
int Max_rampUp = 500;
int Min_rampUp = 0;
int Chn_rampUp = 100;

// RampUp Values
int rampStatus = 2; // 0 : Not Initiated, 1 : Under Rampup, 2 : Done
unsigned long rampStartTime; // time when the rampUp started. 
unsigned long currentTime;

int mode = 0; // 0:Freq, 1:volume, 2:Ramp Up, 3:Manual 

U8G2_ST7565_NHD_C12864_F_4W_HW_SPI screen(U8G2_R2, PIN_LCD_CS, PIN_LCD_A0, PIN_LCD_RESET);
AD9833 ad9833 = AD9833(400000, PIN_DDS_CS);
VarRes varres = VarRes(400000, PIN_RESISTOR_CS);

void setup() {
  
  // Initialize Pins
  pinMode(PIN_IO_TERMINAL1, OUTPUT);
  pinMode(PIN_IO_TERMINAL2, OUTPUT);
  pinMode(PIN_IO_TERMINAL3, OUTPUT);
  pinMode(PIN_IO_TERMINAL4, OUTPUT);
  pinMode(PIN_BTN_CLK, INPUT_PULLUP);
  pinMode(PIN_CS_TRIGGER, INPUT_PULLUP);
  pinMode(PIN_BTN_R1, INPUT_PULLUP);
  pinMode(PIN_BTN_R2, INPUT_PULLUP);
  pinMode(PIN_RESISTOR_CS, OUTPUT);
  pinMode(PIN_DDS_CS, OUTPUT);

  Serial.begin(9600);
  // TODO randomSeed(millis());
  // printWelcomeMsg();
  SPI.begin();
  screen.begin();
  screen.clearDisplay();  
  screen.setContrast(100);
  screen.clearDisplay();
 

  screen.drawXBM(0, 0, 128, 64, welcome);
  screen.updateDisplay();

  // Initialize output pins
  digitalWrite(PIN_IO_TERMINAL1, LOW);
  digitalWrite(PIN_IO_TERMINAL2, LOW);
  digitalWrite(PIN_IO_TERMINAL3, LOW);
  digitalWrite(PIN_IO_TERMINAL4, LOW);

  digitalWrite(PIN_RESISTOR_CS, HIGH);

  digitalWrite(PIN_DDS_CS, HIGH);

  while (millis() < 2000){};

  // Load Default Settings
  ad9833.sendReset();
  ad9833.sendFrequency(freq);
  ad9833.sendControl();
  varres.setVolume(0);

}

void setOutputState(bool state)
{
  if(state)
  {
    digitalWrite(PIN_IO_TERMINAL1, HIGH);
    digitalWrite(PIN_IO_TERMINAL2, HIGH);
    digitalWrite(PIN_IO_TERMINAL3, HIGH);
    digitalWrite(PIN_IO_TERMINAL4, HIGH);  
  }
  else
  {
    digitalWrite(PIN_IO_TERMINAL1, LOW);
    digitalWrite(PIN_IO_TERMINAL2, LOW);
    digitalWrite(PIN_IO_TERMINAL3, LOW);
    digitalWrite(PIN_IO_TERMINAL4, LOW);
  }
  
}

// TODO retain the last selected experimentIndex
int selectedExperimentIndex = 0;
enum UIState
{
  UI_select_experiment,
  UI_show_experiment_outline,
  UI_run_experiment
};
  
int currentUI = UI_select_experiment;

struct ExpParam
{
  double habituation_time;
  double cs_duration;
  double us_onset;
  double us_duration;
  double iti_duration_min;
  double iti_duration_max;
  int num_trial;
};

ExpParam expParam;
bool currR1;
bool currR2;
bool prevR1;
bool prevR2;

void loop() {
  /******************************************************/
  /*                  Select Experiment                 */
  /******************************************************/
  while(currentUI != UI_run_experiment)
  {
    currR1 = !digitalRead(PIN_BTN_R1);
    currR2 = !digitalRead(PIN_BTN_R2);
    if(prevR1 == true && prevR2 == true)
    {
      if(currR1 == true && currR2 == false)
      {
        val++;
      }
      else if (currR1 == false && currR2 == true)
      {
        val--;
      }
    }
    prevR1 = currR1;
    prevR2 = currR2;
  }
  /******************************************************/
  /*             Experiment - Habituation               */
  /******************************************************/

  bool emergency_stop = false;

  long hab_onset_time_ms = millis();

  while((millis() - hab_onset_time_ms) < expParam.habituation_time*1000)
  {
    // emergency stop
    if (Serial1.available() && (char(Serial1.read()) == 's'))
    {
      Serial1.println("Emergency Stop");
      BT.write(letter_EXEnd);
      emergency_stop = true;
      break;
    }
  }
  Serial1.println("Hab End");
//
//  long trial_onset_time_ms;
//  long time_from_trial_onset_ms;
//  long us_duration_ms;
//  long iti_duration_ms;
//
//  bool isITI = false; 
//  bool isCSOn = false;
//  bool isUSArmed; // if true, US is present in this trial, but not yet executed
//  bool isUSOn = false;
//
//  for(int curr_trial=1; curr_trial<= param.num_trial; curr_trial++)
//  {
//    if(emergency_stop) break;
//    Serial1.println("+-------------------------------------------------+");
//    Serial1.print("Trial : ");
//    Serial1.print(curr_trial);
//    
//    // Setup Trial Variables
//    us_duration_ms = random(param.us_duration_min*1000, param.us_duration_max*1000);
//    iti_duration_ms = random(param.isi_duration_min*1000, param.isi_duration_max*1000);
//
//    // if cs_duration is more than zero, turn on the sound
//    // if cs_duration is zero, then skip the CS presentation
//    if(param.cs_duration > 0)
//    {
//      BT.write(letter_cson);
//      Serial1.print(" CS ");
//      Serial1.print(param.cs_duration,2);
//      Serial1.print("s ");
//      digitalWrite(PIN_TONE_GEN, HIGH);
//      isCSOn = true;
//    }
//
//    // if the Experiment Mode is Conditioning, US is armed
//    // if the Experiment Mode is Extinction or Retention, US is not armed
//    if (mode == CONDITIONING)
//    {
//      isUSArmed = true;
//      Serial1.print("US ");
//      Serial1.print(param.us_onset);
//      Serial1.print("-");
//      Serial1.print(us_duration_ms/1000,2);
//      Serial1.println("s");
//    }
//    else
//    {
//      isUSArmed = false;
//      Serial1.println("US X");
//    }
//
//    trial_onset_time_ms = millis();
//
//    while(true)
//    {
//      time_from_trial_onset_ms = millis() - trial_onset_time_ms;
//
//      // check if cs_duration has reached
//      if(isCSOn && (time_from_trial_onset_ms > param.cs_duration*1000))
//      {
//        BT.write(letter_csoff);
//        digitalWrite(PIN_TONE_GEN, LOW);
//        isCSOn = false;
//      }
//
//      // if US is armed, check if us_onset has reached
//      if(isUSArmed && (time_from_trial_onset_ms >= param.us_onset*1000))
//      {
//        if(random(0,100) < 50) motorForward();
//        else motorBackward();
//        isUSArmed = false;
//        isUSOn = true;
//      }
//
//      // if US is on, check if us_duration has reached
//      if(isUSOn && (time_from_trial_onset_ms > (param.us_onset*1000 + us_duration_ms)))
//      {
//        motorStop();
//        isUSOn = false;
//      }
//
//      // if everything is finished during this trial, exit the while loop
//      if(!isCSOn && !isUSArmed && !isUSOn) break;
//
//      // emergency stop
//      if (Serial1.available() && (char(Serial1.read()) == 's'))
//      {
//        Serial1.println("Emergency Stop");
//        BT.write(letter_EXEnd);
//        emergency_stop = true;
//        break;
//      }
//    }
//
//    Serial1.print("ITI start. Current ITI : ");
//    Serial1.print(iti_duration_ms);
//    Serial1.println(" ms");
//    long iti_onset_time_ms = millis();
//    while((millis() - iti_onset_time_ms) < iti_duration_ms)
//    {
//      // emergency stop
//      if (Serial1.available() && (char(Serial1.read()) == 's'))
//      {
//        Serial1.println("Emergency Stop");
//        BT.write(letter_EXEnd);
//        emergency_stop = true;
//        break;
//      }
//    }
//    Serial1.println("ITI end");
//  }
//  Serial1.println("Experiment Done");
//
//  
//
//
//
//// +---------------------------------------------------------------------------------+
//// |                                     CS On Off                                   |
//// +---------------------------------------------------------------------------------+
//  soundOn = !digitalRead(PIN_BTN_CLK) || !digitalRead(PIN_CS_TRIGGER);
//  // If CS state is changed, set rampStatus to 0 (Not initiated)
//  if(soundOn != prevSoundOn) rampStatus = 0;
//  
//  if(soundOn){ // If CS should be on, 
//    if(rampStatus == 0){ // If this is the first loop of the ramp up, 
//      // start ramping up
//      Serial.println("Start Rampup");
//      rampStartTime = millis();
//      if (rampDuration == 0){ // If no rampup is set, just move to the loudest volume and finish rampup.
//        rampStatus = 2;
//        varres.setVolume(volume);
//      }
//      else { // If rampup is set, set rampStatus to 1 (under change) and set the lowest volume.
//        rampStatus = 1;
//        varres.setVolume(Min_volume);
//      }
//      ad9833.sendControl();
//      setOutputState(true);
//    }
//    else if (rampStatus == 1) { // If currently under ramp up, 
//      currentTime = millis() - rampStartTime; 
//      if (currentTime < rampDuration){
//        varres.setVolume(round(currentTime/(double)rampDuration*(volume - Min_volume))+Min_volume);
//      }
//      else rampStatus = 2;
//    }
//  } 
//  else { // If CS should be off,
//    if(rampStatus == 0){ // If this is the first loop of the ramp down
//      // start ramping down
//      Serial.println("Start Rampdown");
//      rampStartTime = millis();
//      if (rampDuration == 0){ // If no rampdown is set, just kill the DDS
//        rampStatus = 2;
//        ad9833.sendReset();
//        setOutputState(false);
//      }
//      else rampStatus = 1; // If rampdown is set, set rampStatus to 1 (under change)
//    }
//    else if (rampStatus == 1) { // if currently under ramp down,
//      currentTime = millis() - rampStartTime; 
//      if (currentTime < rampDuration){
//        varres.setVolume(volume - round(currentTime/(double)rampDuration*(volume - Min_volume)));
//      }
//      else {
//        rampStatus = 2;
//        ad9833.sendReset();
//        setOutputState(false);
//      }
//    }
//  }
//  prevSoundOn = soundOn;
}
